<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cs61a(二）</title>
      <link href="/2025/05/18/CS61A%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/05/18/CS61A%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><ul><li><strong>整数（<code>int</code>）</strong>：用于表示整数，可以是任意大小。Python 3 中的 <code>int</code> 是无界的，这意味着它可以表示任意大的整数，只要计算机的内存足够。</li><li><strong>浮点数（<code>float</code>）</strong>：用于表示小数。浮点数的表示是近似的，这意味着它们不能精确表示所有的小数值。浮点数的精度是有限的，这在进行复杂的数学运算时可能会导致误差。</li><li><strong>复数（<code>complex</code>）</strong>：用于表示复数，包含实部和虚部</li><li><strong>布尔类型（<code>bool</code>）</strong>：用于表示逻辑值，只有两个可能的值：<code>True</code> 和 <code>False</code>。布尔类型在条件语句和逻辑运算中非常有用。</li><li><strong>字符串（<code>str</code>）</strong>：用于表示文本数据。字符串是不可变的，这意味着一旦创建，就不能修改。</li><li><strong>元组（<code>tuple</code>）</strong>：用于表示一组不可变的值。元组可以包含不同类型的数据。</li><li><strong>列表（<code>list</code>）</strong>：是一种可变的序列类型，用于表示一组有序的值。列表可以包含不同类型的数据，并且可以动态地添加或删除元素</li><li><strong>字典（<code>dict</code>）</strong>：是一种键值对的集合，用于表示一组无序的键值对。字典的键必须是不可变类型（如字符串、整数或元组），而值可以是任意类型。</li><li>自定义数据类型在后面面对对象时再说吧</li></ul><h2 id="2-数据抽象"><a href="#2-数据抽象" class="headerlink" title="2. 数据抽象"></a>2. 数据抽象</h2><p>在编程中，数据抽象是一种强大的设计方法，它允许我们将<strong>数据的表示与数据的使用分离</strong>。通过数据抽象，我们可以构建更加模块化、易于维护和修改的程序。数据抽象的核心思想是将数据的表示与数据的使用分离。这意味着我们可以通过定义一组抽象的操作来处理数据，而不需要关心数据的具体表示细节。这种分离使得程序更加模块化，也更容易维护和修改。 </p><ul><li>抽象屏障<br>抽象屏障是数据抽象中的一个重要概念。它通过一组选择器和构造器函数来实现，这些函数定义了如何创建和操作抽象数据。抽象屏障的作用是隐藏数据的具体表示，使得程序的其他部分只需要通过这些函数来操作数据。抽象屏障使得程序的各个部分之间保持独立性。通过抽象屏障，我们可以轻松地修改数据的表示，而不需要修改使用数据的代码。例如，我们可以将有理数的表示从列表改为元组，而不需要修改 <code>add_rationals</code>、<code>mul_rationals</code> 等函数（只需修改<code>rational</code>这个函数）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rational</span>(<span class="hljs-params">n, d</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回分子为 n、分母为 d 的有理数&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> [n, d]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">numer</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回有理数 x 的分子&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">denom</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回有理数 x 的分母&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_rationals</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回两个有理数 x 和 y 的和&quot;&quot;&quot;</span><br>    nx, dx = numer(x), denom(x)<br>    ny, dy = numer(y), denom(y)<br>    <span class="hljs-keyword">return</span> rational(nx * dy + ny * dx, dx * dy)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mul_rationals</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回两个有理数 x 和 y 的乘积&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> rational(numer(x) * numer(y), denom(x) * denom(y))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_rational</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;打印有理数 x&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(numer(x), <span class="hljs-string">&#x27;/&#x27;</span>, denom(x))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rationals_are_equal</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;检查两个有理数 x 和 y 是否相等&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> numer(x) * denom(y) == numer(y) * denom(x)<br><br><span class="hljs-keyword">from</span> fractions <span class="hljs-keyword">import</span> gcd<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rational</span>(<span class="hljs-params">n, d</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回分子为 n、分母为 d 的有理数，简化为最简形式&quot;&quot;&quot;</span><br>    g = gcd(n, d)<br>    <span class="hljs-keyword">return</span> (n // g, d // g)<br></code></pre></td></tr></table></figure><p>有理数这个例子可以很好的阐释什么是数据抽象。</p><h2 id="3-序列"><a href="#3-序列" class="headerlink" title="3. 序列"></a>3. 序列</h2><p>Python 提供了多种内置的序列类型，如列表和范围，它们都满足序列抽象的条件。这里以列表举例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 成员资格</span><br>digits = [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">in</span> digits)  <span class="hljs-comment"># 输出 True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1828</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> digits)  <span class="hljs-comment"># 输出 True</span><br><span class="hljs-comment"># 切片</span><br>digits = [<span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>]<br><span class="hljs-built_in">print</span>(digits[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># 输出 [1, 8]</span><br><span class="hljs-built_in">print</span>(digits[<span class="hljs-number">1</span>:])   <span class="hljs-comment"># 输出 [8, 2, 8]</span><br><span class="hljs-comment"># 加减法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Berkeley&#x27;</span> + <span class="hljs-string">&#x27;, CA&#x27;</span>)  <span class="hljs-comment"># 输出 &#x27;Berkeley, CA&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Shabu &#x27;</span> * <span class="hljs-number">2</span>)         <span class="hljs-comment"># 输出 &#x27;Shabu Shabu &#x27;</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>序列遍历</strong><br>在许多情况下，我们希望依次遍历序列的元素并根据元素值执行一些计算。这种情况十分常见，所以 Python 提供了一个额外的控制语句来处理序列的数据：<code>for</code> 循环语句。考虑统计一个值在序列中出现了多少次的问题。我们也可以使用 <code>while</code> 循环实现一个函数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">s, value</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;统计在序列 s 中出现了多少次值为 value 的元素&quot;&quot;&quot;</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> elem == value:<br>                total = total + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> total<br><span class="hljs-meta">&gt;&gt;&gt; </span>count(digits, <span class="hljs-number">8</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>))<br>[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>))<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><ul><li><strong>序列处理</strong><br><strong>列表推导式（List Comprehensions）</strong>：许多序列操作可以通过对序列中的每个元素使用一个固定表达式进行计算，并将结果值保存在结果序列中。在 Python 中，列表推导式是执行此类计算的表达式。&#96;&#96;&#96;</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>odds = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[x+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> odds]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>另一个常见的序列操作是选取原序列中满足某些条件的值。列表推导式也可以表达这种模式，例如选择 <code>odds</code> 中所有可以整除 25 的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> odds <span class="hljs-keyword">if</span> <span class="hljs-number">25</span> % x == <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>列表推导式的一般形式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">[&lt;<span class="hljs-built_in">map</span> expression&gt; <span class="hljs-keyword">for</span> &lt;name&gt; <span class="hljs-keyword">in</span> &lt;sequence expression&gt; <span class="hljs-keyword">if</span> &lt;<span class="hljs-built_in">filter</span> expression&gt;]<br><span class="hljs-comment"># 举个例子</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">divisors</span>(<span class="hljs-params">n</span>): <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>] + [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n) <span class="hljs-keyword">if</span> n % x == <span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>divisors(<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <br><span class="hljs-meta">&gt;&gt;&gt; </span>divisors(<span class="hljs-number">12</span>) <br><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h2 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h2><p>在计算机科学中，文本值可能比数字更重要。比如 Python 程序是以文本形式编写和存储的。Python 中文本值的内置数据类型称为字符串（string），对应构造函数 <code>str</code>。<br>字符串字面量（string literals）可以表示任意文本，使用时将内容用单引号或双引号括起来。</p><p>字符串与序列有很多共通之处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>city = <span class="hljs-string">&#x27;Berkeley&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(city)<br><span class="hljs-number">8</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>city[<span class="hljs-number">3</span>]<br><span class="hljs-string">&#x27;k&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Berkeley&#x27;</span> + <span class="hljs-string">&#x27;, CA&#x27;</span><br><span class="hljs-string">&#x27;Berkeley, CA&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Shabu &#x27;</span> * <span class="hljs-number">2</span><br><span class="hljs-string">&#x27;Shabu Shabu &#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;here&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Where&#x27;s Waldo?&quot;</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>字符串强制转换（String Coercion）</strong>：通过以对象值作为参数调用 <code>str</code> 的构造函数，可以从 Python 中的任何对象创建字符串。字符串的这一特性在用构造各种类型对象的描述性字符串时非常有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27; is an element of &#x27;</span> + <span class="hljs-built_in">str</span>(digits)<br><span class="hljs-string">&#x27;2 is an element of [1, 8, 2, 8]&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h2><p>树是一种层次化的数据结构，用于表示具有层次关系的数据。树由节点组成，每个节点可以有多个子节点，这个以图片方式来看会很直观。<br>以下是树的基本函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tree</span>(<span class="hljs-params">root_label, branches=[]</span>):<br>    <span class="hljs-keyword">return</span> [root_label] + <span class="hljs-built_in">list</span>(branches)<span class="hljs-comment"># 树</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">label</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-keyword">return</span> tree[<span class="hljs-number">0</span>]<span class="hljs-comment"># 树的标签，第一个</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">branches</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-keyword">return</span> tree[<span class="hljs-number">1</span>:]<span class="hljs-comment"># 树的支</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_tree</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(tree) != <span class="hljs-built_in">list</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(tree) &lt; <span class="hljs-number">1</span>:<span class="hljs-comment"># 非列表，长度为1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> branch <span class="hljs-keyword">in</span> branches(tree):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_tree(branch):<span class="hljs-comment"># 分支必须是树</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_leaf</span>(<span class="hljs-params">tree</span>):<span class="hljs-comment"># 叶就是非树的支</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> branches(tree)<br></code></pre></td></tr></table></figure><p>树递归（Tree-recursive）函数可用于构造树。例如，我们定义 The <strong>n</strong>th Fibonacci tree 是指以第 n 个斐波那契数为根标签的树。那么当 n &gt; 1 时，它的两个分支也是 Fibonacci tree。这可用于说明斐波那契数的树递归计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_tree</span>(<span class="hljs-params">n</span>):<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> tree(n)<br>        <span class="hljs-keyword">else</span>:<br>            left, right = fib_tree(n-<span class="hljs-number">2</span>), fib_tree(n-<span class="hljs-number">1</span>)<br>            fib_n = label(left) + label(right)<br>            <span class="hljs-keyword">return</span> tree(fib_n, [left, right])<br><span class="hljs-meta">&gt;&gt;&gt; </span>fib_tree(<span class="hljs-number">5</span>)<br>[<span class="hljs-number">5</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, [<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>]]], [<span class="hljs-number">3</span>, [<span class="hljs-number">1</span>, [<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>]], [<span class="hljs-number">2</span>, [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, [<span class="hljs-number">0</span>], [<span class="hljs-number">1</span>]]]]]<br></code></pre></td></tr></table></figure><p>其实还是很简单的，想清楚斐波那契数列是什么样的，还是很简单的<br><strong>树递归</strong>同时也可以做到遍历计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 树的遍历</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_leaves</span>(<span class="hljs-params">tree</span>):<br>    <span class="hljs-keyword">if</span> is_leaf(tree):<span class="hljs-comment"># 是叶子就回复1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        branch_counts = [count_leaves(b) <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> branches(tree)]<span class="hljs-comment"># 从头到尾遍历</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(branch_counts)<br><br>t = tree(<span class="hljs-number">3</span>, [tree(<span class="hljs-number">1</span>), tree(<span class="hljs-number">2</span>, [tree(<span class="hljs-number">1</span>), tree(<span class="hljs-number">1</span>)])])<br><span class="hljs-built_in">print</span>(count_leaves(t))  <span class="hljs-comment"># 输出 4</span><br></code></pre></td></tr></table></figure><p><strong>e.g.</strong><br>依然是分割树，思想还是一样的，但是用树，会多一个label,并且是以T&#x2F;F来判断分支的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition_tree</span>(<span class="hljs-params">n, m</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回将 n 分割成不超过 m 的若干正整数之和的分割树&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> tree(<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> m == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> tree(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">else</span>:<br>            left = partition_tree(n-m, m)<br>            right = partition_tree(n, m-<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> tree(m, [left, right])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>partition_tree(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>[<span class="hljs-number">2</span>, [<span class="hljs-literal">True</span>], [<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>, [<span class="hljs-literal">True</span>], [<span class="hljs-literal">False</span>]], [<span class="hljs-literal">False</span>]]]<br></code></pre></td></tr></table></figure><p>其实更重要的是这个打印函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_parts</span>(<span class="hljs-params">tree, partition=[]</span>):<br>        <span class="hljs-keyword">if</span> is_leaf(tree):<br><span class="hljs-string">&#x27;&#x27;&#x27;如果当前节点是叶子节点，且该叶子节点的标签为 `True`，则表示当前路径上的分割方案是有效的。&#x27;&#x27;&#x27;</span><br>            <span class="hljs-keyword">if</span> label(tree):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; + &#x27;</span>.join(partition))<br>        <span class="hljs-keyword">else</span>:<br>            left, right = branches(tree)<span class="hljs-comment"># 由前面可知，并非叶节点，肯定为两个分支--左右</span><br>            m = <span class="hljs-built_in">str</span>(label(tree))<br><span class="hljs-string">&#x27;&#x27;&#x27;将当前节点的标签值（即当前分割的部分大小）转换为字符串&#x27;&#x27;&#x27;</span><br>            print_parts(left, partition + [m])<br>            print_parts(right, partition)<br><span class="hljs-string">&#x27;&#x27;&#x27;递归调用 `print_parts` 函数处理左分支 `left`，并将当前的分割部分 `m` 添加到 `partition` 列表中，形成新的分割累积列表。右边就没有了&#x27;&#x27;&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print_parts(partition_tree(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>))<br><span class="hljs-number">4</span> + <span class="hljs-number">2</span><br><span class="hljs-number">4</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span><br><span class="hljs-number">3</span> + <span class="hljs-number">3</span><br><span class="hljs-number">3</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br><span class="hljs-number">3</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span><br><span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">2</span><br><span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span><br><span class="hljs-number">2</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span><br><span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="6-链表"><a href="#6-链表" class="headerlink" title="6. 链表"></a>6. 链表</h2><p>链表由节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。在Python中，我们可以使用列表来模拟链表的结构。例如，创建一个包含四个元素的链表：1 → 2 → 3 → 4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">four = link(<span class="hljs-number">1</span>, link(<span class="hljs-number">2</span>, link(<span class="hljs-number">3</span>, link(<span class="hljs-number">4</span>, empty))))<br></code></pre></td></tr></table></figure><p>这个链表的结构如下：</p><p><code>[1, [2, [3, [4, &#39;empty&#39;]]]]</code></p><p>其中：</p><ul><li>头节点是 1，指向下一个节点。</li><li>第二个节点是 2，指向下一个节点。</li><li>第三个节点是 3，指向下一个节点。</li><li>第四个节点是 4，指向空值 <code>empty</code>，表示链表的结束。<br>以下是链表的基本函数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>empty = <span class="hljs-string">&#x27;empty&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_link</span>(<span class="hljs-params">s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;判断 s 是否为链表&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> s == empty <span class="hljs-keyword">or</span> (<span class="hljs-built_in">len</span>(s) == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> is_link(s[<span class="hljs-number">1</span>]))<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">link</span>(<span class="hljs-params">first, rest</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;用 first 和 rest 构建一个链表&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> is_link(rest), <span class="hljs-string">&quot; rest 必须是一个链表&quot;</span><br>        <span class="hljs-keyword">return</span> [first, rest]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">first</span>(<span class="hljs-params">s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回链表 s 的第一个元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> is_link(s), <span class="hljs-string">&quot; first 只能用于链表&quot;</span><br>        <span class="hljs-keyword">assert</span> s != empty, <span class="hljs-string">&quot;空链表没有第一个元素&quot;</span><br>        <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">rest</span>(<span class="hljs-params">s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回 s 的剩余元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> is_link(s), <span class="hljs-string">&quot; rest 只能用于链表&quot;</span><br>        <span class="hljs-keyword">assert</span> s != empty, <span class="hljs-string">&quot;空链表没有剩余元素&quot;</span><br>        <span class="hljs-keyword">return</span> s[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>链表很多东西都需要自己定义，其基本的思路就是循环剥壳</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">len_link</span>(<span class="hljs-params">s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回链表 s 的长度&quot;&quot;&quot;</span><br>        length = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> s != empty:<br>            s, length = rest(s), length + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> length<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">getitem_link</span>(<span class="hljs-params">s, i</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回链表 s 中索引为 i 的元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span>:<br>            s, i = rest(s), i - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> first(s)<br></code></pre></td></tr></table></figure><p>所以递归+rest()就能构成链表的基本架构<br>下面的就是链表的另外一些函数与其实现方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">extend_link</span>(<span class="hljs-params">s, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回一个在 s 链表的末尾连接 t 链表后的延长链表&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> is_link(s) <span class="hljs-keyword">and</span> is_link(t)<br>        <span class="hljs-keyword">if</span> s == empty:<br>            <span class="hljs-keyword">return</span> t<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> link(first(s), extend_link(rest(s), t))<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>extend_link(four, four)<br>[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;empty&#x27;</span>]]]]]]]]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">apply_to_all_link</span>(<span class="hljs-params">f, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;应用 f 到 s 中的每个元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> is_link(s)<br>        <span class="hljs-keyword">if</span> s == empty:<br>            <span class="hljs-keyword">return</span> s<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> link(f(first(s)), apply_to_all_link(f, rest(s)))<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>apply_to_all_link(<span class="hljs-keyword">lambda</span> x: x*x, four)<br>[<span class="hljs-number">1</span>, [<span class="hljs-number">4</span>, [<span class="hljs-number">9</span>, [<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;empty&#x27;</span>]]]]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">keep_if_link</span>(<span class="hljs-params">f, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回 s 中 f(e) 为 True 的元素&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> is_link(s)<br>        <span class="hljs-keyword">if</span> s == empty:<br>            <span class="hljs-keyword">return</span> s<br>        <span class="hljs-keyword">else</span>:<br>            kept = keep_if_link(f, rest(s))<br>            <span class="hljs-keyword">if</span> f(first(s)):<br>                <span class="hljs-keyword">return</span> link(first(s), kept)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> kept<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>keep_if_link(<span class="hljs-keyword">lambda</span> x: x%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>, four)<br>[<span class="hljs-number">2</span>, [<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;empty&#x27;</span>]]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">join_link</span>(<span class="hljs-params">s, separator</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;返回由 separator 分隔的 s 中的所有元素组成的字符串&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> s == empty:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">elif</span> rest(s) == empty:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(first(s))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(first(s)) + separator + join_link(rest(s), separator)<br><span class="hljs-meta">&gt;&gt;&gt; </span>join_link(four, <span class="hljs-string">&quot;, &quot;</span>)<br><span class="hljs-string">&#x27;1, 2, 3, 4&#x27;</span><br></code></pre></td></tr></table></figure><p>后面还有用链表实现分割树，这样算下来已经用函数式，树，链表三种形式去实现分割树了，基本思路都是一样的。</p><p><em>又是一篇技术博客，好耶！<br>这次的链表是又学了一遍重新写的笔记，也是重新体会到了链表的魅力（不过还是浅尝即止罢了）。<br>此外还有一件喜事，我成功转到计算机了！！</em></p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs61a </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61A（一）</title>
      <link href="/2025/05/13/CS61A%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/05/13/CS61A%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-函数作为抽象工具"><a href="#1-函数作为抽象工具" class="headerlink" title="1. 函数作为抽象工具"></a>1. 函数作为抽象工具</h2><p>函数的一个重要特性是它们可以作为抽象工具，隐藏实现细节。这意味着你可以定义一个函数，而不需要关心它的具体实现，只要知道它的输入和输出即可。<br>这也是cs61a的核心</p><p><strong>纯函数（Pure functions）</strong>：函数有一些输入（参数）并返回一些输出（调用返回结果）。不改变输出性质，如数学函数<br><strong>非纯函数（Non-pure functions）</strong>：除了返回值外，调用一个非纯函数还会产生其他改变解释器和计算机的状态的副作用（side effect）。如print()，输出其实是none，副产物是显示了你的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">print</span>(<span class="hljs-number">2</span>))<br><span class="hljs-number">1.2</span><br>none,none<br></code></pre></td></tr></table></figure><p>由此，<code>print</code> 函数返回 <code>None</code>  意味着它不应该用于赋值语句，不能使用嵌套。</p><p>实现函数的一个细节就是，实现者为函数的形参选择的名称不应该影响函数行为。所以，以下函数应该提供相同的行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> mul(x, x)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">y</span>):<br>    <span class="hljs-keyword">return</span> mul(y, y)<br></code></pre></td></tr></table></figure><p>一个函数的含义应该与编写者选择的<code>参数</code>名称无关，这个原则对编程语言有重要的意义。最简单的就是函数的参数名称必须在保持函数体局部范围内。</p><h2 id="2-语句与表达式"><a href="#2-语句与表达式" class="headerlink" title="2. 语句与表达式"></a>2. 语句与表达式</h2><p>在 Python 中，语句和表达式是两种不同的概念。表达式是有值的，例如 <code>2 + 2</code> 或 <code>x * y</code>，它们可以被求值并返回一个结果。而语句则是用来执行某些操作的，它们没有值，但会改变程序的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span>  <span class="hljs-comment"># 赋值语句</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):  <span class="hljs-comment"># def 语句</span><br>    <span class="hljs-keyword">return</span> x * x  <span class="hljs-comment"># return 语句</span><br></code></pre></td></tr></table></figure><p>语句的作用是执行某些操作，而不是返回一个值。例如，赋值语句会将一个值绑定到一个变量上，<code>def</code> 语句会定义一个函数，而 <code>return</code> 语句会从函数中返回一个值。</p><p>复合语句是由多个语句组成的结构，它们通常跨越多行，以单行头部开始，并以冒号结尾。复合语句的头部定义了语句的类型，而缩进的句体则包含了要执行的语句。条件语句（if，else）与while是最典型的复合语句</p><h2 id="3-函数调用与环境模型"><a href="#3-函数调用与环境模型" class="headerlink" title="3. 函数调用与环境模型"></a>3. 函数调用与环境模型</h2><p>调用一个函数时，Python 会创建一个新的局部环境（或称为帧），在这个环境中，函数的参数被绑定到传递给函数的实际值上。函数体中的代码在这个局部环境中执行，这意味着函数内部的变量不会影响外部的变量。</p><p>例如，调用 <code>square(4)</code> 时，Python 会创建一个新的局部帧，将参数 <code>x</code> 绑定到值 <code>4</code>，然后执行 <code>return x * x</code>，最终返回 <code>16</code>。</p><p>这种环境模型确保了函数的局部性，使得函数的实现细节对外部代码透明。每个函数调用都有自己的局部帧，即使多次调用同一个函数，每次调用都有独立的局部帧。</p><h2 id="4-局部变量与全局变量"><a href="#4-局部变量与全局变量" class="headerlink" title="4. 局部变量与全局变量"></a>4. 局部变量与全局变量</h2><p>在函数内部定义的变量称为局部变量，它们只在函数的局部帧中有效。与之相对的是全局变量，它们在全局帧中定义，可以在任何地方访问，但不能在函数内部直接修改，除非明确声明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span>  <span class="hljs-comment"># 全局变量</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    x = <span class="hljs-number">20</span>  <span class="hljs-comment"># 局部变量</span><br>    <span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># 输出 20</span><br><br>func()<br><span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># 输出 10</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>func</code> 内部的 <code>x</code> 是局部变量，不会影响全局变量 <code>x</code></p><h2 id="5-函数调用"><a href="#5-函数调用" class="headerlink" title="5. 函数调用"></a>5. 函数调用</h2><p>模块导入的两种常见方式——<code>import math</code> 和 <code>from math import sqrt</code>  </p><p><code>import math</code>：隔离的命名空间</p><ul><li><p>将整个 <code>math</code> 模块导入，但模块内的函数&#x2F;变量需通过 <code>math.</code> 访问。可以有效避免命名冲突<br><code>from math import sqrt</code>：扁平化到全局作用域</p></li><li><p>将 <code>sqrt</code> 函数直接注入当前全局作用域，可直接调用（如 <code>sqrt()</code>）。</p></li></ul><h2 id="6-参数默认值"><a href="#6-参数默认值" class="headerlink" title="6. 参数默认值"></a>6. 参数默认值</h2><p>定义通用函数的结果是引入了额外的参数。具有许多参数的函数可能调用起来很麻烦并且难以阅读。</p><p>在 Python 中，我们可以为函数的参数提供默认值。当调用该函数时，具有默认值的参数是可选的。如果未提供，则将默认值绑定到形参上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pressure</span>(<span class="hljs-params">v, t, n=<span class="hljs-number">6.022e23</span></span>):<br><span class="hljs-string">&quot;&quot;&quot;计算理想气体的压力，单位为帕斯卡 使用理想气体定律：</span><br><span class="hljs-string">v -- 气体体积，单位为立方米 </span><br><span class="hljs-string">t -- 绝对温度，单位为开尔文</span><br><span class="hljs-string">n -- 气体粒子，默认为一摩尔 &quot;&quot;&quot;</span> <br>k = <span class="hljs-number">1.38e-23</span> <br><span class="hljs-comment"># 玻尔兹曼常数 return n * k * t / v</span><br></code></pre></td></tr></table></figure><p><code>=</code> 符号在此示例中表示两种不同的含义，具体取决于使用它的上下文。在 def 语句中，<code>=</code> 不执行赋值，而是指示调用 <code>pressure</code> 函数时使用的默认值。相比之下，函数体中对 <code>k</code> 的赋值语句中将名称 <code>k</code> 与玻尔兹曼常数的近似值进行了绑定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pressure(<span class="hljs-number">1</span>, <span class="hljs-number">273.15</span>)<br><span class="hljs-number">2269.974834</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pressure(<span class="hljs-number">1</span>, <span class="hljs-number">273.15</span>, <span class="hljs-number">3</span> * <span class="hljs-number">6.022e23</span>)<br><span class="hljs-number">6809.924502</span><br></code></pre></td></tr></table></figure><p><code>pressure</code> 函数的定义接收三个参数，但上面的第一个调用表达式中只提供了两个。在这种情况下，<code>n</code> 的值取自 <code>def</code> 语句中的默认值。如果提供了第三个参数，默认值将被忽略。</p><h2 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h2><p>测试是验证程序正确性的重要手段。在 Python 中，我们可以使用 <code>assert</code> 语句来验证函数的输出是否符合预期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x<br><br><span class="hljs-keyword">assert</span> square(<span class="hljs-number">2</span>) == <span class="hljs-number">4</span>, <span class="hljs-string">&quot;square(2) 应该返回 4&quot;</span><br></code></pre></td></tr></table></figure><p>如果 <code>assert</code> 语句中的表达式为真，则程序继续执行；如果为假，则程序会抛出一个错误，并显示指定的错误信息。</p><p>除了 <code>assert</code> 语句，Python 还提供了 <code>doctest</code> 模块，用于编写和运行文档测试。文档测试允许我们将测试用例直接写在函数的文档字符串中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回前 n 个自然数的和。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; sum_naturals(10)</span><br><span class="hljs-string">    55</span><br><span class="hljs-string">    &gt;&gt;&gt; sum_naturals(100)</span><br><span class="hljs-string">    5050</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k &lt;= n:<br>        total, k = total + k, k + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> total<br></code></pre></td></tr></table></figure><p>通过 <code>doctest</code> 模块，我们可以运行这些测试用例，验证函数的正确性，后面的作业检测用这个很多。</p><h2 id="8-高阶函数"><a href="#8-高阶函数" class="headerlink" title="8. 高阶函数"></a>8. 高阶函数</h2><p>高阶函数（Higher-Order Functions）是函数式编程中的一个重要概念。它们可以接受其他函数作为参数，或者返回函数作为结果。这种特性使得高阶函数能够将通用的编程模式抽象化，从而提高代码的复用性和可读性。<br>以下是作为参数传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">summation</span>(<span class="hljs-params">n, term</span>):<br>    total, k = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> k &lt;= n:<br>        total, k = total + term(k), k + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> total<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">identity</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x * x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pi_term</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">8</span> / ((<span class="hljs-number">4</span> * x - <span class="hljs-number">3</span>) * (<span class="hljs-number">4</span> * x - <span class="hljs-number">1</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_naturals</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> summation(n, identity)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_cubes</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> summation(n, cube)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pi_sum</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> summation(n, pi_term)<br></code></pre></td></tr></table></figure><p>高阶函数不仅可以作为参数传递，还可以作为通用方法来表达复杂的计算逻辑。例如，我们可以定义一个通用的迭代改进算法 <code>improve</code>，它接受两个函数作为参数：一个更新函数 <code>update</code> 和一个检查函数 <code>close</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">improve</span>(<span class="hljs-params">update, close, guess=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> close(guess):<br>        guess = update(guess)<br>    <span class="hljs-keyword">return</span> guess<br></code></pre></td></tr></table></figure><p>通过这种方式，我们可以用 <code>improve</code> 函数来实现计算黄金比例的算法： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">golden_update</span>(<span class="hljs-params">guess</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / guess + <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">square_close_to_successor</span>(<span class="hljs-params">guess</span>):<br>    <span class="hljs-keyword">return</span> approx_eq(guess * guess, guess + <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">approx_eq</span>(<span class="hljs-params">x, y, tolerance=<span class="hljs-number">1e-15</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x - y) &lt; tolerance<br><br>phi = improve(golden_update, square_close_to_successor)<br></code></pre></td></tr></table></figure><h2 id="9-柯里化："><a href="#9-柯里化：" class="headerlink" title="9. 柯里化："></a>9. <strong>柯里化</strong>：</h2><p>强制逐参数分解，如 <code>f(a)(b)(c)</code>。<br>def嵌套可以让全局帧更明朗，不至于混乱，更好的来维护全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">curry2</span>(<span class="hljs-params">f</span>): <span class="hljs-string">&quot;&quot;&quot;返回给定的双参数函数的柯里化版本&quot;&quot;&quot;</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">x</span>): <br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">y</span>):<br>         <span class="hljs-keyword">return</span> f(x, y)<br>        <span class="hljs-keyword">return</span> h<br>    <span class="hljs-keyword">return</span> g<br><br></code></pre></td></tr></table></figure><p>柯里化可以这样看：f(x)(y)&#x3D;(f(x))(y),</p><p><code>curry2</code> 函数接受一个双参数函数 <code>f</code> 并返回一个单参数函数 <code>g</code>。当 <code>g</code> 应用于参数 <code>x</code> 时，它返回一个单参数函数 <code>h</code>。当 <code>h</code> 应用于参数 <code>y</code> 时，它调用 <code>f(x, y)</code>。因此，<code>curry2(f)(x)(y)</code> 等价于 <code>f(x, y)</code></p><h2 id="10-匿名函数lambda"><a href="#10-匿名函数lambda" class="headerlink" title="10.  匿名函数lambda"></a>10.  匿名函数lambda</h2><p>一个 lambda 表达式的计算结果是一个函数，它仅有一个返回表达式作为主体。不允许使用赋值和控制语句。匿名函数，使用方法相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br> s = <span class="hljs-keyword">lambda</span> x: x * x<br><span class="hljs-meta">&gt;&gt;&gt; </span>s<br>&lt;function &lt;<span class="hljs-keyword">lambda</span>&gt; at <span class="hljs-number">0xf3f490</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>s(<span class="hljs-number">12</span>)<br><span class="hljs-number">144</span><br></code></pre></td></tr></table></figure><h2 id="11-函数装饰器"><a href="#11-函数装饰器" class="headerlink" title="11. 函数装饰器"></a>11. 函数装饰器</h2><p>函数装饰器（Decorator）是一种特殊的语法，用于在定义函数时应用高阶函数。装饰器可以用来扩展函数的功能，而不需要修改函数的定义。</p><p>例如，我们可以定义一个 <code>trace</code> 装饰器来追踪函数的调用，这也是我目前看到过的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">fn</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; &#x27;</span>, fn, <span class="hljs-string">&#x27;(&#x27;</span>, x, <span class="hljs-string">&#x27;)&#x27;</span>)<br>        <span class="hljs-keyword">return</span> fn(x)<br>    <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">@trace</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">triple</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> * x<br></code></pre></td></tr></table></figure><p>通过这种方式，我们可以用 <code>trace</code> 装饰器来追踪 <code>triple</code> 函数的调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">triple(<span class="hljs-number">12</span>)  <span class="hljs-comment"># 输出 -&gt;  &lt;function triple at 0x102a39848&gt; ( 12 ) 和 36</span><br></code></pre></td></tr></table></figure><h2 id="12-递归函数"><a href="#12-递归函数" class="headerlink" title="12. 递归函数"></a>12. 递归函数</h2><p>递归函数是一种在其函数体中直接或间接调用自身的函数。递归函数的关键在于能够将一个复杂的问题分解为更简单的问题，直到问题变得足够简单可以直接解决。这种分解过程通常被称为“递归分解”。</p><p>如：计算一个正整数的所有数字位之和。例如，数字 18117 的数字位之和是 1 + 8 + 1 + 1 + 7 &#x3D; 18。我们可以使用递归函数来实现这一功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_digits</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回正整数 n 的所有数字位之和&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">else</span>:<br>        all_but_last, last = n // <span class="hljs-number">10</span>, n % <span class="hljs-number">10</span><br>        <span class="hljs-keyword">return</span> sum_digits(all_but_last) + last<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>sum_digits</code> 函数将问题分解为两部分：<br> 最后一位数字 <code>n % 10</code>。足够简单，即基线条件<br>  除最后一位以外的所有数字的和 <code>sum_digits(n // 10)</code>。</p><p>递归函数通常具有以下结构：<br><strong>基线条件</strong>：定义了最简单的情况，直接返回结果。<br><strong>递归调用</strong>：将问题分解为更简单的问题，并调用自身来解决这些子问题。</p><h2 id="13-树递归"><a href="#13-树递归" class="headerlink" title="13. 树递归"></a>13. 树递归</h2><p>树递归是指一个函数在每次调用时会生成多个递归调用。这种模式在解决某些问题时非常自然和直观。例如，计算斐波那契数列的递归实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>fib(n)</code> 会生成两个递归调用 <code>fib(n - 1)</code> 和 <code>fib(n - 2)</code>。这种树递归的结构使得问题的分解非常直观，但可能会导致大量的重复计算。这个可能需要先看看树那一节才能更好理解了。</p><h2 id="14-分割数"><a href="#14-分割数" class="headerlink" title="14. 分割数"></a>14. 分割数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_partitions</span>(<span class="hljs-params">n, m</span>):   <br><span class="hljs-string">&quot;&quot;&quot;计算使用最大数 m 的整数分割 n 的方式的数量&quot;&quot;&quot;</span>     <br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>     <br><span class="hljs-keyword">elif</span> n &lt; <span class="hljs-number">0</span>:     <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>     <br><span class="hljs-keyword">elif</span> m == <span class="hljs-number">0</span>: <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <br> <span class="hljs-keyword">else</span>:     <br>     <span class="hljs-keyword">return</span> count_partitions(n-m, m) + count_partitions(n, m-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>使用最大数为 m 的整数分割 n 的方式的数量等于</p><ol><li>使用最大数为 m 的整数分割 n-m 的方式的数量，加上&#x2F;&#x2F;即，存在一个m，继续分割，这个直到n-m-m-m….每一次减就是一层，直到小于m，这个分之就变成余数被m-1分割……（即2的情况）</li><li>使用最大数为 m-1 的整数分割 n 的方式的数量，递归，直到变成最小，不是最小就回到1的情况分割<br>分割(6,4)<br>即包含4和不包含4的，不包含4的再分成包含3和不包含3的……</li></ol><p><em>哦哦哦，第一篇技术博客完成啦~<br>虽然写的很简略，而且只是看公开课的笔记整理了一下就发上来了，不过还是很有成就感的嘛~<br>目前还都是存货，下一篇应该会有些新内容吧~</em></p>]]></content>
      
      
      <categories>
          
          <category> cs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cs61a </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>THE FIRST BOLG</title>
      <link href="/2025/05/11/THE-FIRST-BOLG/"/>
      <url>/2025/05/11/THE-FIRST-BOLG/</url>
      
        <content type="html"><![CDATA[<p>今天是母亲节，先祝我的妈妈节日快乐吧~</p><h1 id="母亲节快乐，您辛苦了！"><a href="#母亲节快乐，您辛苦了！" class="headerlink" title="母亲节快乐，您辛苦了！"></a>母亲节快乐，您辛苦了！</h1><p>我想多一种方式来记录自己，也能方便你们以另一种方式了解我，所以我创建了这个博客。</p><h2 id="希望大家能够喜欢！！！"><a href="#希望大家能够喜欢！！！" class="headerlink" title="希望大家能够喜欢！！！"></a>希望大家能够喜欢！！！</h2><p>正如标签所说，这个博客更多会更新一些技术相关的思考，日常的一些随笔，与“二次元”相关的内容（这个表述就很宽泛了，哈哈哈）。<br><em>介绍一下自己（也是方便以后的回顾）</em><br>我是一名大一的本科生，热爱<strong>computer science</strong>的内容（可能起因是为了自己写游戏攻略而被迫接触逆向？？？），目前学习过<strong>cs50，cs61a</strong>和计算机视觉与目标检测等内容，才疏学浅，还需努力。<br>网站的图标是初音未来的玩偶（<strong>fufu</strong>），副标题出自亚托利，用户头像是<strong>zaurlane</strong>的<strong>helena</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 母亲节 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>这是一个关于，以后会补的<br>ciallo~</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
